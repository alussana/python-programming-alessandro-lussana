###################################################################
# Set of rules to perform protein sequences analysis and modeling #
###################################################################

# TODO add rule to download swissprot

# index a protein database in fasta format
# try:
# alessandro@MULE:~/Unibo/python-programming-alessandro-lussana/LB1/db$ \
# snakemake -p uniprot_sprot.phr
# MEMO: the rule will also generate the following two files
# {db}.pin
# {db}.psq
rule index_protein_database:
    input:
        "{db}.fasta.gz"
    output:
        phr="{db}.fasta.phr"
    params:
        "{db}"
    shell:
        "zcat {input} > {params}.fasta;"
        " formatdb -i {params}.fasta -p T"

# run blast on local database; the output is in tabular format
# try:
# alessandro@MULE:~/Unibo/python-programming-alessandro-lussana/LB1/db$ \
# snakemake -p query_vs_uniprot_sprot_e0.001_blast_out.gz
rule homology_search:
    input:
        db="{database}.fasta",
        query="{query}.fasta",
        phr="{database}.fasta.phr"
    output:
        "{query}_vs_{database}_e{evalue}_blast_out.gz"
    params:
        "{evalue}"
    shell:
        "blastpgp -i {input.query} -d {input.db} -e {params} -m 8"
        "| gzip > {output}"

# run blast on local database; the output is in tabular format
# try:
# [...]
# MEMO: e-value is stored in 11th column
# MEMO -e option is hard-coded: basically you want to get printed every score
rule blast_run:
    input:
        db="{database}.fasta",
        query="{query}.fasta",
        phr="{database}.fasta.phr"
    output:
        "{query}_vs_{database}_blast_run.gz"
    shell:
        "blastpgp -i {input.query} -d {input.db} -e 1000000000 -m 8 "
        "| gzip > {output}"

# fetch the sequences from uniprot given a list of uniprot IDs
# try:
# alessandro@MULE:~/Unibo/python-programming-alessandro-lussana/LB1/db$ \
# snakemake -p id_for_MSA.fasta.gz
rule fetch_fasta_from_uniprot:
    input:
        "{id_list}.txt"
    output:
        "{id_list}.uniprot.fasta.gz"
    shell:
        "mkdir tmp;"
        " for i in $(cat {input}); do"
        " wget https://www.uniprot.org/uniprot/$i.fasta -O tmp/$i.fasta; done;"
        " cat tmp/*.fasta | gzip > {output};"
        " rm -fr tmp/"

# perform MSA with muscle using default parameters
# try:
# alessandro@MULE:~/Unibo/python-programming-alessandro-lussana/LB1/db$ \
# snakemake -p id_for_MSA_muscle_out.aln.gz
# TODO add params to tune the muscle's parameters
rule muscle_align:
    input:
        "{sequences}.fasta.gz"
    output:
        "{sequences}_muscle_out.aln.gz"
    shell:
        "muscle -in <(zcat {input}) | gzip > {output}"

# train a hidden markov model with hmmer from an alignment in stockholm format
# try:
# (base) alessandro@MULE:~/Unibo/python-programming-alessandro-lussana/LB1$ \
# snakemake -p globin.hmm
rule build_hmm:
    input:
        "{msa}.sto"
    output:
        "{msa}.hmm"
    shell:
        "hmmbuild {output} {input}"

# generate random sequences with a hmm
# try:
# (base) alessandro@MULE:~/Unibo/python-programming-alessandro-lussana/LB1$ \
# snakemake -p globin_emit5.fasta.gz
rule emit_sequence:
    input:
        "{model}.hmm"
    output:
        "{model}_emit{N}.fasta.gz"
    params:
        "{N}"
    shell:
        "hmmemit -N {params} {input} | gzip > {output}"

# perform database search with a hmm
# try:
# (base) alessandro@MULE:~/Unibo/python-programming-alessandro-lussana/LB1$ \
# snakemake -p globin_vs_globin_emit5.search_out.gz
rule hmm_db_search:
    input:
        "{db}.fasta.gz"
    output:
        "{model}_vs_{db}.search_out.gz"
    params:
        "{model}.hmm"
    shell:
        "hmmsearch {params} <(zcat {input}) | gzip > {output}"

# create a library of models to efficiently perform database search
# W! hmm files have to be concat together manually
# TODO solve the W
# this rule also creates the following files:
# {models}.hmm.h3m
# {models}.hmm.h3f
# {models}.hmm.h3p
# try:
# (base) alessandro@MULE:~/Unibo/python-programming-alessandro-lussana/LB1$ \
# snakemake -p global.hmm.h3i
rule build_hmm_library:
    input:
        "{models}.hmm"
    output:
        "{models}.hmm.h3i"
    params:
        "{models}"
    shell:
        "hmmpress {params}.hmm"

# scan a database with a library of hmm
# try:
# (base) alessandro@MULE:~/Unibo/python-programming-alessandro-lussana/LB1$ \
# snakemake -p global_vs_globin_emit5.scan_out.gz
rule hmm_db_scan:
    input:
        "{db}.fasta.gz"
    output:
        "{models}_vs_{db}.scan_out.gz"
    params:
        "{models}.hmm"
    shell:
        "hmmscan {params} <(zcat {input}) | gzip > {output}"

# filter a multifasta given a list of identifiers
# try:
# snakemake -p idlist_filter_on_uniprot_sprot.fasta.gz
rule filterfasta:
    input:
        db = "{db}.fasta.gz",
        fl = "{filter}.txt"
    output:
        "{filter}_filter_on_{db}.fasta.gz"
    shell:
        "python ../src/fastafilter.py {input.db} {input.fl} | gzip > {output}"

# sample N items from a list
# try:
# snakemake -p sprot_pf00014_non_human_id_sampled18.txt
rule random_sampling:
    input:
        "{list}.txt"
    output:
        "{list}_sampled{N}.txt"
    params:
        "{N}"
    shell:
        "cat {input} | sort -R | sed -n '1,{params}p' > {output}"

# list the target identifiers with their lowest e-value computed in a blast search
# try:
# (base) alessandro@MULE:~/Unibo/python-programming-alessandro-lussana/LB1/prj/dataset$ \
# snakemake -p sprot_pf00014_human_id_filter_on_swissprot_vs_sprot_non_pf00014_global_id_sampled500_filter_on_swissprot_blast_min_eval.gz
rule list_min_evalues:
    input:
        "{blast_run}_blast_run.gz"
    output:
        "{blast_run}_blast_min_eval.gz"
    shell:
        "for id in $(zcat {input} | cut -f2 | sort | uniq); do"
        " zcat {input} | grep $id | cut -f2,11 | LC_ALL=c sort -gk2 | sed -n '1p';"
        " done | gzip > {output}"

# generate list of examples to later feed a confusion matrix
# try:
# (base) alessandro@MULE:~/Unibo/python-programming-alessandro-lussana/LB1/prj/dataset$ \
# snakemake -p conf_list_of_sprot_pf00014_human_id_filter_on_swissprot_vs_sprot_pf00014_non_human_id_filter_on_swissprot_and_sprot_pf00014_human_id_filter_on_swissprot_vs_sprot_non_pf00014_global_id_sampled500_filter_on_swissprot.gz
rule compute_confusion_matrix:
    input:
        p="{p}_blast_min_eval.gz",
        n="{n}_blast_min_eval.gz"
    output:
        "conf_list_of_{p}_and_{n}.gz"
    shell:
        "cat"
        " <(zcat {input.p} | awk '{{print $0\"\t\"1}}')"
        " <(zcat {input.n} | awk '{{print $0\"\t\"0}}')"
        " | gzip > {output}"

####################
# deprecated rules #
####################

# filter a multifasta given a list of identifiers
# try:
# snakemake -p idlist_filter_on_uniprot_sprot.fasta.gz
# W! Snakemake thinks that the output file might be corrupted;
# the rule works actually properly
#rule filterfasta:
#    input:
#        "{db}.fasta.gz"
#    output:
#        "{filter}_filter_on_{db}.fasta.gz"
#    params:
#        "{filter}.txt"
#    shell:
#        "for entry in $(cat {params}); do"
#        " zcat uniprot_sprot.fasta.gz | awk -v entry=$entry"
#        " '{{ if($0~entry){{print $0; getline; while($0 !~ /^>/)"
#        " {{print $0; getline}}; exit }} }}'; done"
#        " | gzip > {output}"
